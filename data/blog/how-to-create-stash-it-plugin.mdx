---
title: 'How to create stash-it plugin'
date: '2024-09-16'
tags: ['stash-it', 'how to', 'plugin']
draft: false
summary: "In my last post I introduced stash-it and briefly explained how it works. Now it's time to build a plugin for it."
---

## Flow of data

### How data flows through hook handlers

Understanding this is crucial for plugins creation:

1. Every hook handler has reference to the adapter injected `{ adapter, ...rest }`. In case you need to do something
   on the data in the storage (get/set/remove/...) - you can do so.
1. Every hook handler is expected to return the same set of data its been given (apart from `adapter`, this one is not
   passed further and is injected automatically). For example `beforeHasItem` is passed `{ key, adapter }` and is expected
   to return `{ key }`; `beforeSetItem` is passed `{ key, value, extra, adapter }` and is expected to return `{ key, value, extra }`,
   and so on. This ensures that multiple handlers registered for given hook will be given the same set of data always.

### Closer look at `setItem`

I will explain `setItem` method, as the rest of the public methods behave the same way (except for `registerPlugins` of course).
The only difference is arguments they receive and pass through hook handlers.

```ts
// 1
async setItem(key: Key, value: Value, extra: Extra = {}): Promise<Item> {
  // 2
  await this.#adapter.connect();

  try {
    // 3
    const builtKey = await this.#buildKey(key);
    // 4
    const beforeData = await this.#call("beforeSetItem", { key: builtKey, value, extra });
    // 5
    const setItem = await this.#adapter.setItem(beforeData.key, beforeData.value, beforeData.extra);
    // 6
    const afterData = await this.#call("afterSetItem", { ...beforeData, item: setItem });
    // 7
    await this.#adapter.disconnect();
    // 8
    return afterData.item;
  } catch (error) {
    // 9
    await this.#adapter.disconnect();
    throw error;
  }
}
```

Let's go through each step one by one.

1. `setItem` method is called.

   ```ts
   async setItem(key: Key, value: Value, extra: Extra = {}): Promise<Item>
   ```

   It expects `key`, `value` and optional `extra` arguments (if `extra` is not passed, the default value is used).
   It's important to know that for all of the methods, the `before...` hook handlers will receive the arguments
   passed to the method in question.

1. Connection to storage is established.

   ```ts
   await this.#adapter.connect()
   ```

   Depending on where you will be storing the data, adapter will need to connect to that storage (or not).
   E.g. [MemoryAdapter](https://jsr.io/@stash-it/memory-adapter) doesn't have to connect,
   but [RedisAdapter](https://jsr.io/@stash-it/redis-adapter) does.
   This step is not directly connected to plugin creation.

1. Building the key.

   ```ts
   const builtKey = await this.#buildKey(key)
   ```

   This method takes the `key` value passed to `setItem` method.

   At this moment, the `buildKey` hook handlers are being called (if registered).
   `buildKey` hook handler is called with `{ key, adapter }`.

   Example:

   ```ts
   // This handler does nothing, simply ilustrating what gets in, and what is expected out.
   async buildKeyHookHandler({ key, adapter }) {
     return { key }
   }
   ```

   Let's say, you want to add a prefix (so that every item stored is prefixed with some string):

   ```ts
   async buildKeyHookHandler({ key }) {
     const prefixedKey = `some_prefix_${key}`;

     return { key: prefixedKey }
   }
   ```

1. The `beforeSetItem` hook gets called (thus executing any registered handlers for it).

   ```ts
   const beforeData = await this.#call('beforeSetItem', { key: builtKey, value, extra })
   ```

   At this point, you can do something with the data that will create the item, before it (data) is passed
   to the adapter that will persist it.

   At this point, if the `key` was modified in the `buildKey` step, that value is now used.

   Let's look at an example:

   ```ts
   // `beforeSetItem` handler example, if it did not do anything
   async beforeSetItemHandler({ key, value, extra, adapter }) {
     return { key, value, extra };
   }
   ```

   Let's say we want to log the value that is passed (for whatever reason):

   ```ts
   async beforeSetItemHandler({ key, value, extra }) {
     console.log(value);

     return { key, value, extra };
   }
   ```

   Or you need to check that if the item exists, and if it does, throw an error (because you should
   not overwrite already existing items):

   ```ts
   async beforeSetItemHandler({ key, value, extra, adapter }) {
     const itemExists = await adapter.hasItem(key);

     if (itemExists) {
       throw new Error('Overwriting items is not allowed!');
     }

     return { key, value, extra };
   }
   ```

   <aside className="rounded bg-gray-50 px-5 py-0.5 dark:bg-gray-800">
     <strong>Head's up:</strong> throwing an error is a good way to terminate the execution of each
     stash-it's methods.
   </aside>

1. Setting the item using the adapter.

   ```ts
   const setItem = await this.#adapter.setItem(beforeData.key, beforeData.value, beforeData.extra)
   ```

   As you can see, all the arguments come from `beforeData` which is the data returned from calling
   the `beforeSetItem` hook handlers.

   The result of setting the item is returned. There are no hooks/handlers at this point.

1. The `afterSetItem` hook gets called (thus executing any registered hook handlers for this hook).

   ```ts
   const afterData = await this.#call('afterSetItem', { ...beforeData, item: setItem })
   ```

   As storing the item has no hook, the last data we have comes from `beforeSetItem` and the item that
   was just stored. And those are used here.

1. Connection to the storage is closed.

   ```ts
   await this.#adapter.disconnect()
   ```

   Depending on where you will be storing the data, adapter will need to disconnect from that storage (or not).
   E.g. [MemoryAdapter](https://jsr.io/@stash-it/memory-adapter) doesn't have to do it,
   but [RedisAdapter](https://jsr.io/@stash-it/redis-adapter) does.
   This step is not directly connected to plugin creation.

1. The item that got created, and which value got passed through `afterSetItem` hook handler is returned.

   ```ts
   return afterData.item
   ```

1. Error handling

   If at any point and exception is thrown (either by one of the hooks or the adapter), error is caught here,
   closing the connection is done (as it was not because of the error) and the error gets rethrown.

And that's it.

### Remaining methods and their hooks

All of them call `buildKey` first.

The remaining methods, meaning: `getItem`, `hasItem`, `removeItem`, `setExtra` and `getExtra` have the same
`before...` and `after...` hooks. Meaning: `beforeGetItem` and `afterGetItem`, and so on.

The flow and behavior is exactly the same as for the `setItem` method.

The only difference is what gets passed around, as some of the methods use fewer data. For instance:

- `setItem` requires `key`, `value` (and optional `extra`)
- `getItem`, `hasItem`, `removeItem` and `getExtra` require only the `key` (to get, check, remove and get the extra of the item)
- `setExtra` requires `key` and `extra` (to set the extra data on the item by its key)

And so, the `before...` hook handlers are passed `key` only, or `key` and `extra`, depending on which method's hook handlers get
called.

I encourage you to have a look at the source code. It's very simple. Also TypeScript helps a lot with autosuggesting.

## Let's build a plugin

I mentioned that you can check if item exists, so that if it does, it is not overwritten. So, let's build a plugin that does that.

```ts
const writeOnlyPlugin = {
  hookHandlers: {
    beforeSetItem: async ({ key, value, extra, adapter }) => {
      const itemExists = await adapter.hasItem(key)

      if (itemExists) {
        throw new Error('Overwriting items is not allowed!')
      }

      return { key, value, extra }
    },
    beforeRemoveItem: async ({ key, adapter }) => {
      const itemExists = await adapter.hasItem(key)

      if (itemExists) {
        throw new Error('Removing items is not allowed!')
      }

      return { key }
    },
    beforeSetExtra: async ({ key, extra, adapter }) => {
      const itemExists = await adapter.hasItem(key)

      if (itemExists) {
        throw new Error('Overwriting data in items is not allowed!')
      }

      return { key }
    },
  },
}
```
