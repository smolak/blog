---
title: 'How to create stash-it plugin'
date: '2024-09-16'
tags: ['stash-it', 'how to', 'plugin']
draft: false
summary: "In my last post I introduced stash-it and briefly explained how it works. Now it's time to build a plugin for it."
---

## Flow of data

Before I jump in into plugin creation, you need to understand the flow of data in methods
that you can hook into.

Let's take a look at `setItem` method first. The rest of the methods behave the same way, except for the `buildKey` one,
which I will explain separately.

```ts
// Source of `setItem` method from stash-it v0.1.3 - the currently newest available
// The API of the method should not change.

// 1
async setItem(key: Key, value: Value, extra: Extra = {}): Promise<Item> {
  // 2
  await this.#adapter.connect();

  // 3
  const beforeData = await this.#call("beforeSetItem", { key, value, extra });

  // 4
  const builtKey = await this.#buildKey(beforeData.key);

  // 5
  const setItem = await this.#adapter.setItem(builtKey, beforeData.value, beforeData.extra);

  // 6
  const afterData = await this.#call("afterSetItem", { ...beforeData, key: builtKey, item: setItem });

  // 7
  await this.#adapter.disconnect();

  // 8
  return afterData.item;
}
```

Let's go through each step one by one.

1. `setItem` method is called.

   ```ts
   async setItem(key: Key, value: Value, extra: Extra = {}): Promise<Item>
   ```

   It expects `key`, `value` and optional `extra` arguments. It's important to know that for all of the methods,
   the `before...` hook handlers will receive the arguments passed to the method in question. See point #3.

1. Connection to storage is established.

   ```ts
   await this.#adapter.connect()
   ```

   Depending on where you will be storing the data, adapter will need to connect to that storage (or not).
   E.g. [MemoryAdapter](https://jsr.io/@stash-it/memory-adapter) doesn't have to connect,
   but [RedisAdapter](https://jsr.io/@stash-it/redis-adapter) does.
   This step is not directly connected to plugin creation.

1. The `beforeSetItem` hook gets called (thus executing any registered hook handlers for this hook).

   ```ts
   const beforeData = await this.#call('beforeSetItem', { key, value, extra })
   ```

   Each method has `before...` hook. `setItem`, at this point, is executing any registered hook handlers
   for the `beforeSetItem` hook. All of the methods' `before...` hook handlers get passed the arguments
   passed to that method. Well, the first handler gets exactly the same values as those passed to the
   `setItem` methods, and any subsequent handlers get values returned by the previously called handlers.
   So, if two handlers are registered for this hook, first will get the values as are, process them,
   possibly do something with them, or change them, and pass them further. Next handler uses the passed
   further values. And so on.

   Additionaly, stash-it injects a reference to the adapter in use, as for some cases,
   plugins might need to reach out to the storage to operate on the data.

   Let's put this together. Let's call `setItem` with `some_key` and `some_value` (`extra` being optional,
   if not passed, uses `{}` value). That means, first registered handler
   for this hook will be called with `some_key`, `some_value`, `{}` and `adapter`.

   As mentioned, each handler must return the same set of data (data structure), so that if there are more
   handlers registered, they can use that data.

   But not the adapter. Each handler call gets it injected, so you don't need to pass it around.

   Let's look at an example:

   ```ts
   // `beforeSetItem` handler example, if it did not do anything
   // Mentioning `adapter` as it is passed, but you don't need to use it, not pass it further.
   async beforeSetItemHandler({ key, value, extra, adapter }) {
    return { key, value, extra };
   }
   ```

   Let's say we wanted to log the value that is passed (for whatever reason):

   ```ts
   async beforeSetItemHandler({ key, value, extra }) {
    console.log(value);

    return { key, value, extra };
   }
   ```

   Or when you wanted to check that if the item exists, it throws an error (vecause you should
   not overwrite already existing items):

   ```ts
   async beforeSetItemHandler({ key, value, extra, adapter }) {
    const itemExists = await adapter.hasItem(key);

    if (itemExists) {
      throw new Error('Overwriting items is not allowed!');
    }

    return { key, value, extra };
   }
   ```

   <aside className="rounded bg-gray-50 px-5 py-0.5 dark:bg-gray-800">
     <strong>Head's up:</strong> throwing an error is a good way to terminate the execution of each
     stash-it's methods.
   </aside>

   As you can see, you can do all types of things in hooks, meaning, you can call all
   methods available on the StashItAdapter interface (see: [types](https://github.com/smolak/stash-it/blob/main/packages/core/src/types.ts)).

1. Building the key.

   ```ts
   const builtKey = await this.#buildKey(beforeData.key)
   ```

   This method takes the `key` value returned from `beforeSetItem`. This is important,
   as if for some reason, one of the handlers were to alter the key (for whatever the reason), that key
   value is to be used here.

   At this moment, the `buildKey` hook event handlers are being called. And like with `beforeSetItem`,
   which takes the arguments passed to the `setItm` method, `buildKey` hook takes arguments passed to
   the `buildKey` stash-it's method. Again, reference to the adapter is also injected here.

   Example:

   ```ts
   // This handler does nothing, simply ilustrating what gets in, and what is expected out.
   async buildKeyHookHandler({ key, adapter }) {
    return { key }
   }
   ```

   Let's say, you want to add a prefix (so that every item stored is prefixed with some string):

   ```ts
   async buildKeyHookHandler({ key }) {
    const prefixedKey = `some_prefix_${key}`;

    return { key: prefixedKey }
   }
   ```

   And so on. You get the point.
